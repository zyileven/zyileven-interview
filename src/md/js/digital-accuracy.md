## Javascript 精度丢失问题

首先先来看一个案例：

```js
console.log(0.1 + 0.2 === 0.3) // false
```

现在想一下数学中存在的除不尽的无限循环小数，如：1 ÷ 3 = 0.33333.....，但是作为计算机，不可能存储一个无限长度的小数，因此只能存储一个近似值，所以当计算机存储后再取出来就会出现精度丢失问题。



### 一、浮点数

浮点数是一种数字格式，常见为 Float，可以用来存储整数和小数。

在 JS 中，主流的数据类型是 Number，而 Number 采用的是 IEEE754 规范中的 64 位双精度浮点数编码。

好处：能同时处理小数和整数

其次，计算机中使用的是二进制（0 和 1），如果使用二进制来代表整数很简单，但是代表小数就相对复杂了。

现在我们复习一下二进制的基础，由于我们这里是 64 位的，所以就按照 64 位来实现：

- 符号位 S：64 位二进制的第一个字符用来控制正负的符号，0 代表正数，1 代表负数
- 指数位 E：中间的 11 位存储指数，用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量位 1023
- 尾数位 M：最后的 52 位是尾数，超出的部分自动进 1 舍 0

举个例子：

27.5 转化为二进制是 11011.1

11011.1 转化为科学记数法为 1.10111 * 2^4

符号为1（因为是正数），指数为为 4，1023+4 =1027

因为是 10 进制转为 2 进制，1027 => 10000000011 ，小数部分为 10111，补够 52 位即：1011 1000 0000 0000 0000 0000 0000  0000 0000 0000 0000 0000

所以 27.5 在计算机中的二进制标准形式（符号位 + 指数位 + 小数部分）为：

0 + 1000000011 + 1011 1000 0000 0000 0000 0000 0000  0000 0000 0000 0000 0000 0000



### 二、如何解决精度问题

为了验证这个问题，我们实现一个方法来转化

```js
function toFloat64Binary(num) {
    // 1. 创建 ArrayBuffer 和 DataView 访问底层二进制
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);

    // 2. 将数值写入缓冲区（使用 Float64 格式）
    view.setFloat64(0, num);

    // 3. 读取底层 64 位二进制（BigInt 避免精度损失）
    const uint64 = view.getBigUint64(0);

    // 4. 转换为 64 位二进制字符串并补前导零
    let binary = uint64.toString(2).padStart(64, '0');

    // 5. 按 IEEE 754 结构分割
    const sign = binary[0];
    const exponent = binary.substring(1, 12);
    const mantissa = binary.substring(12);

    // 6. 特殊值处理（增强可读性）
    if (exponent === '11111111111') {
      if (mantissa === '0000000000000000000000000000000000000000000000000000') {
        return `${sign} | ${exponent} (Infinity) | ${mantissa}`;
      }
      return `${sign} | ${exponent} (NaN) | ${mantissa}`;
    }
    if (exponent === '00000000000') {
      if (mantissa === '0000000000000000000000000000000000000000000000000000') {
        return `${sign} | ${exponent} (${Object.is(num, -0) ? "-0" : "+0"}) | ${mantissa}`;
      }
      return `${sign} | ${exponent} (Denormalized) | ${mantissa}`;
    }

    // 7. 返回标准化格式
    return `${sign} | ${exponent} | ${mantissa}`;
  }
```

现在我们将 0.1和 0.2 都转化为 54 位二进制数：

```js
 console.log(toFloat64Binary(0.1));
// 0 | 01111111011 | 1001100110011001100110011001100110011001100110011010
console.log(toFloat64Binary(0.2));
// 0 | 01111111100 | 1001100110011001100110011001100110011001100110011010
```

现在我们使用二进制的加法进行相加，那么上面的0.1 + 0.2 的结果是：

0 ｜ 01111111101 ｜ 0011001100110011001100110011001100110011001100110011

转化为十进制是：0.3000000000000000444089209850063（即 0.30000000000000004）

**因此 0.1 + 0.2 === 0.3 不成立**

### 三、解决方案

任何时候当你遇到记得计算结果是有很长的小数的时候，提前将数据转化为可计算精度，如：

```js
parseFloat(1.4000000000000000001.toPrecision(12)) === 1.4 // True
```

封装成方法就是：

```js
function strip(number, precision = 12) {
  return +parseFloat(number.toPrecision(precision));
}
```

然后计算使用 strip 处理 0.1 + 0.2 的结果：

```js
console.log(strip(0.1 + 0.2)); // 0.3
```







