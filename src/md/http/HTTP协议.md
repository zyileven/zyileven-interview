## HTTP 协议

### HTTP 概念

`HTTP` (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/03/b2c516df0c4f3b76acba02a43bfdf5ec-fda119b0-b20b-11eb-85f6-6fac77c0c9b3-70521e.png)

在计算机和网络世界有，存在不同的协议，如广播协议、寻址协议、路由协议等等......

而`HTTP`是一个传输协议，即将数据由A传到B或将B传输到A，并且 A 与 B 之间能够存放很多第三方，如： A<=>X<=>Y<=>Z<=>B

传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别

在实际应用中，`HTTP`常被用于在`Web`浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密

特点如下：

- 支持客户/服务器模式
- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快
- 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记
- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
- 无状态：HTTP协议无法根据之前的状态进行本次的请求处理

### HTTPS 概念

为了保证这些隐私数据能加密传输，让`HTTP`运行安全的`SSL/TLS`协议上，即 HTTPS = HTTP + SSL/TLS，通过 `SSL`证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/03/46a5853b3cc8279720b74ec43d0f44b0-cb559400-b2ff-11eb-85f6-6fac77c0c9b3-cd0c22.png)

`SSL` 协议位于`TCP/IP` 协议与各种应用层协议之间，浏览器和服务器在使用 `SSL` 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/03/9ac914dce8946c00bd5d0d96a2222576-0e409fc0-b20c-11eb-85f6-6fac77c0c9b3-a89a25.png)

1. 首先客户端通过URL访问服务器建立SSL连接
2. 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端
3. 客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级
4. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
5. 服务器利用自己的私钥解密出会话密钥
6. 服务器利用会话密钥加密与客户端之间的通信



> **SSL** 
>
> - 对称加密：采用协商的密钥对数据加密
> - 非对称加密：实现身份认证和密钥协商
> - 摘要算法：验证信息的完整性
> - 数字签名：身份验证
>
> **对称加密**
>
> 对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性
>
> ![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/03/6424258a79bdfd8451dde5188948ec15-e3f040f0-b2ff-11eb-ab90-d9ae814b240d-cc772f.png)
>
> **非对称加密**
>
> 非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密
>
> 公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解 密，反过来，私钥加密后也只能用公钥解密
>
> ![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/03/b3878fceee44051ebd834de4bcaac6e6-d9603e60-b2ff-11eb-ab90-d9ae814b240d-13bbe8.png)
>
> **混合加密**
>
> 在`HTTPS`通信过程中，采用的是 对称加密+非对称加密 = 混合加密
>
> `HTTPS`采用非对称加密解决秘钥交换的问题
>
> 具体做法是发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”
>
> ![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/03/a82282cd6e18be3858cddf7c5782d44b-f375f290-b2ff-11eb-85f6-6fac77c0c9b3-274b2c.png)
>
> **摘要算法**
>
> 实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数
>
> 可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”
>
> 摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性
>
> ![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/03/7cdd73ddd0a8d0d2d536f280320536e5-023790e0-b300-11eb-ab90-d9ae814b240d-232bb1.png)
>
> **数字签名**
>
> 数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名
>
> 原理其实很简单，就是用私钥加密，公钥解密
>
> 签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的
>
> ![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/03/15052fee86b5b526e2ef9df92abb1d68-21aa6880-b300-11eb-85f6-6fac77c0c9b3-4ecb3c.png)
>
> 和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥
>
> 这时候就需要一个第三方，就是证书验证机构



### HTTP 与 HTTPS 的区别

- HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全

- HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443

- HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP



### HTTP 状态码

http 状态码就是表示网页服务器超文本传输协议响应状态的3位数字代码

它由 RFC 2616规范定义的，并得到 `RFC 2518`、`RFC 2817`、`RFC 2295`、`RFC 2774`与 `RFC 4918`等规范扩展

简单来讲，`http`状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态

#### 状态码

##### 1xx：表示消息

代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束

常见的有：

- 100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
- 101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级

##### 2xx：表示成功

代表请求已成功被服务器接收、理解、并接受

常见的有：

- 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
- 201（已创建）：请求成功并且服务器创建了新的资源
- 202（已创建）：服务器已经接收请求，但尚未处理
- 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源
- 204（无内容）：服务器成功处理请求，但没有返回任何内容
- 205（重置内容）：服务器成功处理请求，但没有返回任何内容
- 206（部分内容）：服务器成功处理了部分请求

##### 3xx：表示重定向

表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向

常见的有：

- 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
- 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
- 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
- 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码
- 304：说明无需再次传输请求的内容，也就是说可以使用缓存的内容。
- 305 （使用代理）：请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
- 307 （临时重定向）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求



##### 4xx：表示请求错误

代表了客户端看起来可能发生了错误，妨碍了服务器的处理

常见的有：

- 400（错误请求）： 服务器不理解请求的语法
- 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403（禁止）： 服务器拒绝请求
- 404（未找到）： 服务器找不到请求的网页
- 405（方法禁用）： 禁用请求中指定的方法
- 406（不接受）： 无法使用请求的内容特性响应请求的网页
- 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
- 408（请求超时）： 服务器等候请求时发生超时

##### 5xx：表示服务器错误

表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生

常见的有：

- 500（服务器内部错误）：服务器遇到错误，无法完成请求
- 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
- 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
- 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
- 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
- 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本

#### 部分状态码的使用场景

- 100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输
- 206：一般用来做断点续传，或者是视频文件等大文件的加载
- 301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名
- 302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面
- 304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分
- 400：参数有误，请求无法被服务器识别
- 403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回
- 404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时
- 503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503
- 504：网关超时



### GET 与 POST 的区别

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中



### 常见请求头

HTTP头字段（HTTP header fields）,是指在超文本传输协议（HTTP）的请求和响应消息中的消息头部分

它们定义了一个超文本传输协议事务中的操作参数

HTTP头部字段可以自己根据需要定义，因此可能在 `Web`服务器和浏览器上发现非标准的头字段

下面是一个HTTP 请求的请求头

```http
GET /home.html HTTP/1.1
Host: developer.mozilla.org
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://developer.mozilla.org/testpage.html
Connection: keep-alive
Upgrade-Insecure-Requests: 1
If-Modified-Since: Mon, 18 Jul 2016 02:36:04 GMT
If-None-Match: "c561c68d0ba92bbeb8b0fff2a9199f722e3a621a"
Cache-Control: max-age=0
```

| 字段名            | 说明                                                         | 示例                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Accept            | 能够接受的回应内容类型（Content-Types）                      | Accept: text/plain                                           |
| Accept-Charset    | 能够接受的字符集                                             | Accept-Charset: utf-8                                        |
| Accept-Encoding   | 能够接受的编码方式列表                                       | Accept-Encoding: gzip, deflate                               |
| Accept-Language   | 能够接受的回应内容的自然语言列表                             | Accept-Language: en-US                                       |
| Authorization     | 用于超文本传输协议的认证的认证信息                           | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==            |
| Cache-Control     | 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令 | Cache-Control: no-cache                                      |
| Connection        | 该浏览器想要优先使用的连接类型                               | Connection: keep-alive<br /> Connection: Upgrade             |
| Cookie            | 服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie | Cookie: $Version=1; Skin=new;                                |
| Content-Length    | 以 八位字节数组 （8位的字节）表示的请求体的长度              | Content-Length: 348                                          |
| Content-Type      | 请求体的 多媒体类型                                          | Content-Type: application/x-www-form-urlencoded              |
| Date              | 发送该消息的日期和时间                                       | Date: Tue, 15 Nov 1994 08:12:31 GMT                          |
| Expect            | 表明客户端要求服务器做出特定的行为                           | Expect: 100-continue                                         |
| Host              | 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号 | Host: en.wikipedia.org:80 <br />Host: en.wikipedia.org       |
| If-Match          | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源 | If-Match: "737060cd8c284d8af7ad3082f209582d"                 |
| If-Modified-Since | 允许在对应的内容未被修改的情况下返回304未修改                | If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT             |
| If-None-Match     | 允许在对应的内容未被修改的情况下返回304未修改                | If-None-Match: "737060cd8c284d8af7ad3082f209582d"            |
| If-Range          | 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体 | If-Range: "737060cd8c284d8af7ad3082f209582d"                 |
| Range             | 仅请求某个实体的一部分                                       | Range: bytes=500-999                                         |
| User-Agent        | 浏览器的浏览器身份标识字符串                                 | User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 |
| Origin            | 发起一个针对 跨来源资源共享 的请求                           | Origin: http://www.example-social-network.com                |

#### 协商缓存

协商缓存是利用的是`【Last-Modified，If-Modified-Since】`和`【ETag、If-None-Match】`这两对请求头响应头来管理的

`Last-Modified` 表示本地文件最后修改日期，浏览器会在request header加上`If-Modified-Since`（上次返回的`Last-Modified`的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来

`Etag`就像一个指纹，资源变化都会导致`ETag`变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的

`If-None-Match`的header会将上次返回的`Etag`发送给服务器，询问该资源的`Etag`是否有更新，有变动就会发送新的资源回来

而强制缓存不需要发送请求到服务端，根据请求头`expires`和`cache-control`判断是否命中强缓存

强制缓存与协商缓存的流程图如下所示：

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/04/a2b2089fb09d4bffc362070eddb3ea35-a4065b00-bc69-11eb-85f6-6fac77c0c9b3-e994f4.png)

#### 会话状态

`cookie`，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据，通过响应头`set-cookie`决定

作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 `Cookie`有效期、安全性、使用范围的可选属性组成

`Cookie` 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等



### TCP 连接

#### TCP/IP 介绍

TCP/IP，**传输控制协议**/**网际协议**，是指能够在多个不同网络间实现信息传输的协议簇。

- TCP（传输控制协议）：一种面向连接的、可靠的、基于字节流的传输层通信协议

- IP（网际协议）：用于封包交换数据网络的协议

TCP/IP协议不仅仅指的是`TCP`和`IP`两个协议，而是指一个由`FTP`、`SMTP`、`TCP`、`UDP`、`IP`等协议构成的协议簇，

只是因为在`TCP/IP`协议中`TCP`协议和`IP`协议最具代表性，所以通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols）

TCP/IP协议族按层次分别了五层体系或者四层体系

五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层

五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层

如下图所示：

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/05/74350f50b2f2bcf915001cf64219545e-5bb93610-b647-11eb-85f6-6fac77c0c9b3-865023.png)

#### 五层体系

##### 应用层

`TCP/IP` 模型将 `OSI`参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务

如：`FTP`、`Telnet`、`DNS`、`SMTP` 等

##### 传输层

该层对应于 OSI 参考模型的传输层，为上层实体提供**源端**到**对端**主机的通信功能

传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）

其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输

##### 网络层

负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机

在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送

##### 数据链路层

数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧

##### 物理层

保证数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境

#### 四层体系

##### 网络接口层

负责实际数据（帧）的传输，对应OSI参考模型的下两层

**使用的协议**：HDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议）

##### 网络层

负责网络间的寻址数据（数据报）传输，对应OSI参考模型的第三层

**使用的协议**：IP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）

##### 传输层

负责提供可靠的传输服务，对应OSI参考模型的第四层

**使用的协议**：TCP（控制传输协议） UDP（用户数据报协议）

##### 应用层

负责实现一切与应用程序相关的功能，对应OSI参考模型的上三层

**使用的协议**：FTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）



#### 模型的区别

相同点：

- OSI 参考模型与 TCP/IP 参考模型都采用了层次结构
- 都能够提供面向连接和无连接两种通信服务机制

不同点：

- OSI 采用的七层模型； TCP/IP 是四层或五层结构
- TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分
- OSI 参考模型虽然网络划分为七层，但实现起来较困难。TCP/IP 参考模型作为一种简化的分层结构是可以的
- TCP/IP协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 `OSI` 设想中的应用程序维度的分层是无法实现的

三种模型对应关系如下图所示：

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/05/34e65a7225cacd2df7b451d9fae4c762-3fbff4d0-b647-11eb-ab90-d9ae814b240d-e81463.png)







### 域名

##### 域名介绍

域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名...

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/05/c1a939c11b3140b5d9062d07d2706f63-9f112780-b78f-11eb-85f6-6fac77c0c9b3-de7680.png)

例如`www.xxx.com`，`www`为三级域名、`xxx`为二级域名、`com`为顶级域名，系统为用户做了兼容，域名末尾的根域名`.`一般不需要输入

在域名的每一层都会有一个域名服务器，如下图：

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/05/170687bcdba29caee33fe013ebf88e4b-f40e0090-b7a4-11eb-85f6-6fac77c0c9b3-782aab.png)

##### 域名缓存

在域名服务器解析的时候，使用缓存保存域名和`IP`地址的映射

计算机中`DNS`的记录也分成了两种缓存方式：

- 浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
- 操作系统缓存：操作系统的缓存其实是用户自己配置的 `hosts` 文件





### 浏览器从输入 URL 开始做了些什么？

从输入 `URL`到回车后发生的行为如下：

- URL解析
- DNS 查询
- TCP 连接
- HTTP 请求
- 响应请求
- 页面渲染

#### 1.URL 解析

首先判断你输入的是一个合法的`URL` 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作

`URL`的解析第过程中的第一步，一个`url`的结构解析如下：

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/05/1aa6edf791ecef8c29f9962176665eca-27a0c690-bdf4-11eb-ab90-d9ae814b240d-087c3b.png)

通过上面的解析，我们知道了用户的 URL 是想要获取什么东西。

#### 2.DNS 查询

##### DNS 介绍

DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器

简单来讲，`DNS`相当于一个翻译官，负责将域名翻译成`ip`地址

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/05/94fb39274d4174eba118690deeefba7d-965a03a0-b78f-11eb-ab90-d9ae814b240d-113bf2.png)

##### DNS 的查询方式

DNS 查询的方式有两种：

- 递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/05/3e0452b40ab9e6e627f48a18033135c9-a73be9e0-b78f-11eb-85f6-6fac77c0c9b3-8c7e62.png)

> 1：发起请求
>
> 2：跟域名服务器没有数据，自己去请求顶级域名服务器
>
> 3：顶级域名服务器没有数据，自己去请求权限服务器
>
> 4：权限服务器找到数据，返回给顶级域名服务器
>
> 5：顶级域名服务器收到数据，返回给根域名服务器
>
> 6：根域名服务器收到数据，然后返回给本地域名服务器

- 迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求

  ![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/05/5b64a006105197950f86cd5d26e5f99e-b023e1c0-b78f-11eb-85f6-6fac77c0c9b3-acb2fc.png)

>  1：向根域名服务器发起请求
>
> 2：我找不着，我估计顶级域名服务器有，你去找他
>
> 3：向顶级域名服务器发起请求
>
> 4：我找不着，我估计权限服务器有，你去找他
>
> 5：向权限服务器发起请求
>
> 6：我有数据，我现在返回给你



##### DNS 解析域名过程

- 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
- 若没有对应，则继续搜索操作系统的 DNS 缓存
- 若仍然没有命中，则操作系统将域名发送至本地域名服务器①，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果
- 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
  - 首先本地域名服务器向根域名服务器发起请求②，根域名服务器返回顶级域名服务器的地址给本地服务器③
  - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求④，获取权限域名服务器的地址⑤
  - 本地域名服务器根据权限域名服务器的地址向其发起请求⑥，最终得到该域名对应的 IP 地址⑦
- 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来⑧
- 操作系统将 IP 地址返回给浏览器，同时在操作系统 DNS 缓存中保存起来
- 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/05/43e8b400fc66373927b88dbb55434d64-bec3c740-b78f-11eb-ab90-d9ae814b240d-d5e161.png)

#### 3.TCP 连接

`tcp`是一种面向有连接的传输层协议，在确定目标服务器服务器的`IP`地址后，则经历三次握手建立`TCP`连接，流程如下：

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/05/3243c763dd57b7c41f1f8425b6b031c4-ad750790-bdf4-11eb-85f6-6fac77c0c9b3-aa7522.png)

##### 三次握手

三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包，主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。

过程如下：

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态
- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态
- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接

上述每一次握手的作用如下：

- 第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：**客户端的发送能力、服务端的接收能力是正常的。**
- 第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：**服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常**
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：**客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常**

##### 四次挥手

`tcp`终止一个连接，需要经过四次挥手

过程如下：

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/05/dd327394e9e56c6e30fe73dacfc373cc-fdad94b15cd0341b6b5faef349f93e39-bf98fc.png)

服务端在收到客户端断开连接`Fin`报文后，并不会立即关闭连接，而是先发送一个`ACK`包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送`FIN`报文断开连接，因此需要四次挥手













#### 4.发送 http 请求

当建立`tcp`连接之后，就可以在这基础上进行通信，浏览器发送 `http` 请求到目标服务器

请求的内容包括：

- 请求行
- 请求头
- 请求主体

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/05/e1203d0faa8b541d7e1ef1084efc2d47-bbcb60f0-bdf4-11eb-ab90-d9ae814b240d-ba061c.png)

#### 5.响应请求

当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个`HTTP`响应消息，包括：

- 状态行
- 响应头
- 响应正文

```http
HTTP/1.1 200 OK
Date: Sat, 31 Dec 2023 00:00:00 GMT
Content-Type: text/html;charset=ISO-8859-1
Content-Length: 122


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!--  -->
</body>
</html>
```

在服务器响应之后，由于现在`http`默认开始长连接`keep-alive`，当页面关闭之后，`tcp`链接则会经过四次挥手完成断开

#### 6.页面渲染

当浏览器接收到服务器响应的资源后，首先会对资源进行解析：

- 查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储cookie，解压gzip，缓存资源等等
- 查看响应头的 Content-Type的值，根据不同的资源类型采用不同的解析方式

关于页面的渲染过程如下：

- 解析HTML，构建 DOM 树
- 解析 CSS ，生成 CSS 规则树
- 合并 DOM 树和 CSS 规则，生成 render 树
- 布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算
- 绘制 render 树（ paint ），绘制页面像素信息
- 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上

![img](https://raw.githubusercontent.com/zyileven/image-hosting-platform/master/src/2024/03/05/ac055f9eff50b74bf215f3e260753bbe-v2-4bf06c2f03786acc0e00890a6b0cdd48_1440w-dd8d12.webp)

从图中可以看出，渲染引擎主要包含的模块有：

- **HTML解析器**：解析HTML文档，主要作用是将HTML文档转换成DOM树；
- **CSS解析器**：将DOM中的各个元素对象进行计算，获取样式信息，用于渲染树的构建；
- **JavaScript解释器**：使用JavaScript可以修改网页的内容、CSS规则等。JavaScript解释器能够解释JavaScript代码，并通过DOM接口和CSSOM接口来修改网页内容、样式规则，从而改变渲染结果；
- **页面布局**：DOM创建之后，渲染引擎将其中的元素对象与样式规则进行结合，可以得到渲染树。布局则是针对渲染树，计算其各个元素的大小、位置等布局信息。
- **页面绘制**：使用图形库将布局计算后的渲染树绘制成可视化的图像结果。













