# Web Vitals 网页指标

核心 Web 指标是一组指标，可根据加载性能、对用户输入的响应能力和布局稳定性等标准评估用户体验。核心网页指标专门用于衡量用户对您网站的体验，是一组以用户为中心的指标。

**三大核心指标**

三大核心指标分别是 LCP（最大内容绘制）,FID/INP（交互延迟与响应）,CLS（累积布局偏移）。



## 图示页面渲染和加载流程

一下展示从 URL 回车到页面完全加载完成的流程，整合了网络请求、资源解析、渲染流水线及核心性能指标。图中使用符号标注关键节点（`🌐`=网络请求、`🔄`=解析/构建、`🎨`=渲染、`⏱️`=性能指标），并依据浏览器渲染原理分层呈现

时间轴 (单位：ms) 0 → 5000
│
├── **网络请求阶段** ────────────────────────
│   [DNS查询]    🌐 解析域名 → 20ms
│   [TCP握手]    🌐 建立连接 → 50ms
│   [TLS协商]    🌐 HTTPS加密 → 80ms (若用HTTP则跳过)
│   [HTML请求]   🌐 发送请求 → 100ms
│                	⬇️ 服务器响应HTML → 200ms

│
├── **解析与构建阶段** ──────────────────────
│   [DOM构建]    🔄 解析HTML → 构建DOM树 → 300ms
│   [CSSOM构建]  🔄 解析CSS → 构建CSSOM树 → 400ms
│   [JS加载]     🌐 请求JS文件 → 450ms
│                ⬇️ JS下载完成 → 600ms
│                🔄 JS执行 → 阻塞DOM/CSSOM → 700ms
│   [渲染树合成]  🔄 DOM + CSSOM → Render Tree → 800ms
│
├── **渲染流水线** ──────────────────────────
│   [布局计算]    🎨 计算元素位置/尺寸 → 首次重排 → 900ms
│   [首次绘制]    🎨 绘制像素 → FP（首次绘制）→ 1000ms
│   [FCP]        ⏱️ 首次内容绘制（文本/图像可见）→ 1200ms 
│   [LCP]        ⏱️ 最大内容渲染 → 1500ms (可能因图片加载延迟更新)
│   [重排/重绘]   🎨 JS操作DOM → 触发重排 → 1600ms (如修改布局属性)
│                🎨 样式变更 → 重绘 → 1700ms (如背景色修改)
│
├── **交互准备阶段** ────────────────────────
│   [TTI]        ⏱️ 主线程空闲 → 可交互时间 → 3000ms (5秒静默窗口)
│   [TBT]        ⏱️ FCP~TTI阻塞总和 → 累积长任务阻塞 → 500ms 
│   [FID]        ⏱️ 用户首次点击 → 主线程响应延迟 → 50ms (理想≤100ms)
│   [INP]        ⏱️ 持续交互延迟监控 → 全程 
│
├── **视觉稳定性** ──────────────────────────
│   [CLS]        ⏱️ 布局偏移累积 → 全程监控 (如未设尺寸的图片加载)
│
└── **生命周期结束** ────────────────────────
    [页面卸载]    导航离开/关闭 → CLS/INP结束







**1.网络请求优化点**

- DNS预取：`<link rel="dns-prefetch>` 提前解析域名。
- 资源优先级：`<link rel="preload> ` 预加载关键CSS/JS。
- CDN加速：静态资源分发至边缘节点，减少TTFB（如LCP图片）。

**2.资源加载与解析**

- 异步加载：`<script async>` 或 defer 避免阻塞渲染树合成。
- 
- 长任务拆分：将 >50ms 的JS任务拆解，减少TBT。
- DOM离线操作：修改元素时先 display: none，批量操作后显示，减少重排次数。

**3.渲染性能提升**

- GPU加速：对动画元素使用 transform/opacity，跳过重排直接合成。
- 布局抖动规避：避免快速连续读写几何属性（如 offsetTop），防止强制重排。
- 懒加载：非首屏图片/组件延迟加载，减少初始渲染压力。

**4.指标关联与瓶颈定位**

- LCP延迟：常因图片未预加载、服务器响应慢或CSSOM阻塞。
- CLS偏移：动态内容未预留空间（如广告位）或字体未设置 font-display: swap。
- FID/TBT高：主线程被长任务阻塞，需拆分JS或延迟第三方脚本



## 图示页面渲染和加载流程中用户体感

时间轴 (单位：ms) 0 → 5000
│
├── 1. 网络请求阶段 (0-200ms) [🌐]
│   ├── 用户体感：焦虑等待（空白屏）
│   ├── 性能瓶颈：
│   │   - DNS查询慢（新域名）
│   │   - TCP/SSL握手延迟（高RTT）
│   │   - TTFB高（服务器响应慢）
│   └── 优化方案：
│       - DNS预取：`<link rel="dns-prefetch href="//cdn.example.com">`
│       - 启用HTTP/2/3：多路复用降低握手开销
│       - CDN加速静态资源：减少物理距离
│
├── **2. 解析与构建阶段** (200-800ms) [🔄]
│   ├── **用户体感**：持续空白屏，怀疑是否卡死
│   ├── **性能瓶颈**：
│   │   - 大型JS/CSS阻塞DOM/CSSOM构建
│   │   - 同步加载脚本延迟渲染
│   └── **优化方案**：
│       - 异步/延迟JS：`<script async>`或`defer`
│       - 内联关键CSS，非关键样式异步加载
│       - 压缩+Tree Shaking：移除未使用代码
│
├── **3. 渲染流水线** (800-1500ms) [🎨]
│   ├── **用户体感**：
│   │   - **800ms**：欣喜（FCP出现文本/图像）
│   │   - **1500ms**：期待（LCP主内容可见但可能未交互）
│   ├── **性能瓶颈**：
│   │   - 图片/视频未压缩（LCP延迟）
│   │   - 布局偏移（CLS）导致元素跳动
│   └── **优化方案**：
│       - 图片：WebP格式+尺寸预设+懒加载
│       - 视频：第三方托管+点击加载
│       - 预留空间：广告位/图片设置宽高比
│
├── **4. 交互准备阶段** (1500-3000ms) [⚡]
│   ├── **用户体感**：挫败感（点击无响应，怀疑卡顿）
│   ├── **性能瓶颈**：
│   │   - JS长任务阻塞主线程（TBT>200ms）
│   │   - 第三方脚本（广告/分析工具）延迟交互
│   └── **优化方案**：
│       - 拆分长任务：`setTimeout`或Web Workers
│       - 延迟非关键脚本：`requestIdleCallback`
│       - 预加载字体：`<link rel="preload">`避免FOIT
│
├── **5. 完全交互阶段** (3000ms+) [✅]
│   ├── **用户体感**：流畅（TTI达成，操作即时响应）
│   ├── **性能瓶颈**：
│   │   - 异步数据加载慢（如评论模块）
│   │   - FID/INP延迟>100ms（用户可感知卡顿）
│   └── **优化方案**：
│       - 数据分层加载：首屏同步+次屏异步
│       - 缓存策略：SWR/React Query复用接口数据
│       - 骨架屏过渡：避免静态等待
│
└── **6. 视觉稳定性** (全程监控) [📊]
    ├── **用户体感**：烦躁（内容突然移位导致误点）
    ├── **性能瓶颈**：
    │   - 动态插入内容未预留空间（广告/弹窗）
    │   - 字体加载延迟引发布局重排

LC



## LCP （最大内容绘制）

### 概念

LCP 指的是Largest Contentful Paint，最大内容绘制，是 Core Web Vitals 的核心指标之一，用于衡量页面首屏中最大内容块（如图片、视频、标题文本等）完成渲染的时间。它直接影响用户对页面加载速度的感知，是评估用户体验的关键指标。

**理想范围**：≤ 2.5 秒（良好），＞4 秒视为需优化

**触发元素**：

- `<img> `图片或背景图
- `<video>`的封面（poster属性）
- 
  块级文本（如 `<h1>、<div>` 中的大段文字）

### 影响 LCP 的关键因素

1. **服务器响应慢**：首字节时间（TTFB）过高，通常因后端处理延迟、无 CDN 或数据库查询慢导致
2. **资源加载阻塞**：CSS/JS 文件阻塞渲染树构建，延迟 LCP 元素加载
3. **媒体资源未优化**：图片过大、未压缩或未使用现代格式（如 WebP/AVIF）
4. **渲染路径冗长**：DOM 结构复杂、字体加载阻塞文本渲染



### 优化 LCP 的实用方案

#### 1.**服务器端优化**

启用 CDN 与 HTTP/3：使用 Cloudflare、阿里云等 CDN 加速静态资源分发，减少网络延迟

**缓存策略**：

- 设置 Cache-Control 和 ETag 头部，结合 Redis/Memcached 缓存热点内容。
- 静态化首页，避免动态生成（如 SSR 页面预渲染）



#### 2.资源优先级控制

**关键资源优先加载**

- 使用` <link rel="preload"> `预加载 LCP 元素（如首图、关键 CSS）。
- 为 LCP 元素添加 fetchpriority="high"（Chrome 支持）

**非关键资源延迟**

- JS 使用 async/defer 属性；
- 图片添加 loading="lazy"



#### **3.图片与媒体优化**

**格式与压缩**

转换图片为 WebP/AVIF，工具推荐 TinyPNG 或 Squoosh。

**响应式尺寸**

使用 srcset 和 sizes 属性按设备尺寸加载适配图片



#### 4.**减少第三方脚本影响**

**异步加载脚本**

如广告、分析代码添加 async 属性。

**按需引入**

使用动态导入（如 import()）拆分非必要 JS 代码



#### 5.**CSS 与字体优化**

**内联关键 CSS**

将首屏样式直接嵌入 HTML，避免阻塞渲染。

**字体加载策略**

使用 `font-display: swap;` 避免文本闪烁，后备字体优先显示

```css
@font-face {
  font-family: 'CustomFont';
  src: url('font.woff2') format('woff2');
  font-display: swap;
}
```



## FID/INP 

### **FID（首次输入延迟）**

**定义**

FID（First Input Delay）衡量用户首次交互（如点击、按键）到浏览器开始处理该事件的延迟时间。
**核心原理**

- 当用户交互发生时，若主线程被阻塞（如执行长任务、渲染），事件需等待主线程空闲才能被处理。
- FID = processingStart - startTime（即事件触发，到主线程开始处理，的间隔）。

**局限性**

- 仅测量首次交互，忽略后续操作。
- 不包含事件处理及渲染时间，无法全面反映响应体验



### INP（交互到下一次绘制）

**定义**

INP（Interaction to Next Paint）衡量用户任意交互（点击、触摸、按键）到浏览器完成下一帧绘制的总延迟。

**核心原理**

- 交互分为三个阶段：
  - 输入延迟：交互发生到事件回调开始（同FID）。
  - 处理时间：事件回调执行耗时。
  - 渲染延迟：回调结束到下一帧绘制完成。
- INP = 所有交互中最长延迟（取98分位值，排除异常值）。

**优势**

- 覆盖全生命周期交互，更全面反映真实体验。
- 包含完整响应链条（输入→处理→渲染）



### 优化方案

#### FID 优化策略

**减少主线程阻塞：**

- 延迟非关键脚本：使用 defer 或 async 加载非首屏JS。
- 拆分长任务：将JS任务拆分为<50ms的片段，避免阻塞主线程。

**控制第三方脚本：**

- 通过标签管理器（如GTM）延迟加载广告/分析脚本。

**优化渲染资源：**

- 内联关键CSS，避免@import阻塞渲染。
- 使用font-display: swap避免字体加载阻塞



#### **INP 优化策略**

**减少输入延迟**：

- 避免定时器滥用：减少setInterval递归调用，防止与用户争抢主线程。
- 防抖（debounce）高频交互：如表单输入，减少冗余事件处理。

**优化事件处理**：

- 分解长任务：使用requestIdleCallback调度非紧急逻辑。
- 优先级调度：对交互分级（如React的useTransition），优先处理核心操作。

**降低渲染延迟**：

- 减少布局抖动：避免JS强制同步布局（如避免连续读写样式属性）。
- 压缩DOM规模：虚拟列表、懒加载非视口元素（content-visibility属性）。
- GPU加速动画：用CSS动画替代JS动画，减少主线程负载



#### **FID 与 INP 对比**

|   **特性**   |   **FID**    |            **INP**             |
| :----------: | :----------: | :----------------------------: |
| **测量范围** |  仅首次交互  |       全生命周期所有交互       |
| **延迟阶段** |  仅输入延迟  | 输入延迟 + 处理时间 + 渲染延迟 |
| **阈值标准** | ≤100ms（优） |   ≤200ms（优），>500ms（差）   |
| **适用场景** | 初始加载响应 |        长期页面交互体验        |

> **总结**：INP 因更全面评估响应性，已于 **2024年3月正式取代FID** 成为核心Web指标。
>
> 优化需聚焦**主线程空闲度**、**事件处理效率**及**渲染性能**，并结合真实用户监控持续调优。



## CLS（累积布局偏移）

CLS（Cumulative Layout Shift，累积布局偏移）是衡量网页视觉稳定性的核心性能指标，属于Google核心Web指标（Core Web Vitals）之一。它量化了页面加载或交互过程中，元素意外移动的频率和程度，直接影响用户体验和SEO排名。

### **CLS的概念与背景**

#### **定义与作用**

CLS用于统计**页面生命周期内所有意外布局偏移的总和**。布局偏移指元素在渲染帧之间发生非预期的位置变化（如广告加载导致按钮下移），导致用户误操作或内容阅读中断

#### **重要性**

- 用户体验：内容跳动会降低用户信任感，增加跳出率。
- SEO影响：Google将CLS纳入搜索排名算法，高CLS可能导致页面排名下降

### **CLS的核心原理**

CLS的计算基于两个关键因素，结合会话窗口（Session Window）机制：

#### 影响分数（Impact Fraction）

指被移动元素占据的视口面积比例。例如，一个占视口50%的元素移动后，影响分数为0.5：

>
> 公式：影响区域面积 / 视口面积

#### 距离分数（Distance Fraction）

指元素移动距离占视口高度的比例。若元素垂直移动视口高度的25%，距离分数为0.25：

> 公式：最大移动距离 / 视口高度

#### 单次偏移分数与累计规则

- 单次偏移分数 = 影响分数 × 距离分数。

- 会话窗口机制：

  - 页面发生首次偏移时，开启一个最长5秒的窗口。

  - 若1秒内无新偏移，窗口提前关闭。

  - CLS取所有会话窗口中的最高总分值



### **优化CLS的关键策略**

#### **为动态内容预设尺寸**

**图片/视频**

显式设置`width`和`height`属性，或使用CSS `aspect-ratio`锁定宽高比

```html
<img src="banner.jpg" width="800" height="600" alt="示例">
<style>
.container {
  aspect-ratio: 16/9; /* 保持16:9比例 */
}
</style>
```

通过`padding-top`预留空间（如16:9比例设`padding-top: 56.25%`）

```css
padding-top: 56.25%
```

**广告/第三方组件**

为动态插入的内容设置固定占位容器，避免加载后挤压布局

```css
.ad-placeholder {
  min-height: 250px; /* 预留广告位高度 */
  background: #f0f0f0;
}
```

#### **优化字体与资源加载**

**字体防抖动**

使用`font-display: swap`避免字体加载时的布局跳动（FOIT/FOUT），并预加载关键字体

```css
@font-face {
  font-family: 'CustomFont';
  src: url('font.woff2') format('woff2');
  font-display: swap;
}

<link rel="preload" href="font.woff2" as="font" crossorigin>
```

**资源加载策略**

非关键资源（如图片、iframe）添加loading="lazy"延迟加载。

关键资源（如首屏字体）预加载，缩短渲染阻塞时间



#### **控制动态内容注入与动画**

**动态内容占位**

异步加载内容前插入占位元素，避免DOM插入后布局突变

```js
const placeholder = document.createElement('div');
placeholder.style.height = '100px'; // 预留高度
document.body.appendChild(placeholder);
```

**动画优化**

避免使用`margin`或`width`触发布局重排，改用`transform`或`opacity`

```css
/* 劣质方案：引发布局偏移 */
.bad-animation { margin-left: 20px; }

/* 优化方案：仅触发合成层 */
.good-animation { transform: translateX(20px); }
```





相关



































## **TTI（可交互时间）**

TTI（Time to Interactive，可交互时间）是衡量网页加载性能的关键指标，表示**页面从开始加载到用户可流畅交互所需的时间**。它反映了用户实际体验的“可用性”时刻，即用户点击、输入等操作能获得及时响应的临界点。

### **TTI 的核心定义与原理**

TTI 衡量页面达到完全可交互状态的时间点，需满足以下条件：

- 主线程空闲：JavaScript 长任务（>50ms）已执行完毕，主线程可快速处理用户输入。
- 内容可见：首次内容绘制（FCP）已完成，用户能看到有意义的内容。
- 交互响应延迟≤50ms：用户操作（点击、输入）能在50毫秒内被响应。
- 功能就绪：按钮、表单等交互元素的事件处理程序已注册并可用

#### **计算逻辑**

TTI 的计算基于两个关键节点：

- 起点：首次内容绘制（FCP）完成。
- 终点：首个5秒静默窗口（Quiet Window）的开始时间。
  - 静默窗口要求：5秒内无长任务（>50ms）且未完成的网络请求≤2个。
- 最终值：取 FCP 与静默窗口起点之间的最晚时间点（通常为静默窗口前最后一个长任务结束的时间）。

> TTI 的起点，但仅代表内容可见，不保证可交互
>
> 测量 FCP 到 TTI 之间用户首次交互的响应延迟，TTI 完成后 FID 应趋近于0
>
> Google 核心 Web 指标包括 LCP、FID、CLS，但 TTI 仍是优化用户体验的重要参考

### **TTI 变慢的常见原因**

#### JavaScript 执行阻塞

- 长任务堆积：未拆分的复杂脚本（如图像处理、数据初始化）占用主线程。
- 同步加载脚本：阻塞渲染的 <script> 标签延迟 FCP 和 TTI。

#### 资源加载效率低

- 过大 JS/CSS 文件：未压缩或未代码拆分的资源延长下载与解析时间。
- 过多并发请求：图片等非关键资源并行加载占用带宽，增加未完成请求数（影响静默窗口）。

#### 渲染流程优化不足

- 未预加载关键资源：字体、首屏组件未优先加载，拖慢交互准备。
- 第三方脚本阻塞：广告、分析工具等未异步或延迟执行

### **优化 TTI 的关键策略**

#### 减少主线程阻塞

- 拆分长任务：将 >50ms 的 JS 任务拆分为微任务或用 Web Workers 移出主线程。
- 异步/延迟加载脚本：非关键 JS 使用 async 或 defer 属性。

#### 优化资源加载

- 代码分割与懒加载：仅加载当前视图所需 JS（如 React.lazy）。
- 预加载关键资源：`<link rel="preload"> `提前获取字体、首屏组件。
- 压缩与缓存：GZIP 压缩文本资源，设置强缓存（如 Cache-Control: max-age=31536000）。

#### 控制第三方脚本

- 延迟非必要脚本：通过 requestIdleCallback 或在 onload 后加载广告/分析脚本。
- 按需注入：仅当用户触发交互（如点击视频按钮）时加载第三方组件。

#### 性能监控与调试

- 实时监测：用 PerformanceObserver 上报 TTI 数据至监控平台（如 Sentry）。
- 可视化分析：Chrome DevTools 的 Performance 面板定位长任务和请求瓶颈

> TTI 是用户体验从“可见”到“可用”的关键转折点，优化核心在于**减轻主线程负载**与**精细化资源调度**。通过拆分任务、异步加载、预取关键资源等手段，将 TTI 控制在 **2.5秒内**，可显著提升用户留存率与业务转化率











## **TBT（总阻塞时间）**

TBT（Total Blocking Time，总阻塞时间）是衡量网页加载过程中主线程被阻塞程度的关键性能指标，属于实验室指标（Lab Metric），用于量化页面从首次内容绘制（FCP）到可交互时间（TTI）之间用户交互被延迟的总时长。

### **TBT 的定义与原理**

**阻塞时间计算**
当主线程执行的任务耗时超过 50ms（称为“长任务”）时，超出 50ms 的部分即为阻塞时间。例如：

- 任务耗时 60ms → 阻塞时间 = 10ms
- 任务耗时 80ms → 阻塞时间 = 30ms

**TBT 总和**

在 FCP 至 TTI 窗口期内，所有长任务的阻塞时间累加值即为 TBT

### 与用户体验的关系

- 主线程被阻塞时，用户点击、输入等操作无法及时响应，导致卡顿感（响应延迟 >100ms 时用户可感知）。
- TBT 越低，页面加载期间的交互流畅性越高。

### **优化 TBT 的关键策略**

**减少长任务与主线程负载**

- 拆分任务：将 >50ms 的 JS 任务拆分为微任务或使用 Web Workers 移出主线程。
- 异步加载脚本：非关键 JS 添加 async 或 defer 属性，避免阻塞渲染

```html
<script src="analytics.js" async></script>
```

**优化资源加载效率**

- 代码分割与懒加载：仅加载当前视图所需资源（如 React.lazy）。
- 预加载关键资源：使用 `<link rel="preload">` 提前获取字体、首屏组件。
- 压缩与缓存：GZIP 压缩文本资源，设置强缓存（Cache-Control: max-age=31536000）

**控制第三方脚本影响**

- 延迟加载：通过 requestIdleCallback 或在 onload 事件后加载非必要脚本。
- 按需注入：仅当用户触发交互（如点击视频按钮）时加载第三方组件



## **FCP（首次内容绘制）**

FCP（First Contentful Paint，首次内容绘制）是衡量网页加载性能的核心指标之一，属于Google核心Web指标（Core Web Vitals）的组成部分。它反映了用户从开始加载页面到**首次看到任何实际内容**（如文本、图像等）的时间点，是用户感知页面加载速度的关键指标

### **FCP的定义与核心意义**

**基本概念**

FCP 指浏览器首次渲染DOM中有意义内容的时间点，包括：

- 文本：标题、段落等可见文字。
- 图像：包括<img>标签和CSS背景图。
- 非空SVG或Canvas：非白色的绘制元素。
- 注意：不包含iframe内容、纯背景色变化（属于FP）或空白Canvas

**用户体验意义**

FCP 回答用户“页面是否开始加载？”的疑问。当用户看到首个内容时，会减少跳出率并提升信任感。例如：空白屏幕 → FCP出现（如导航栏加载） → 用户感知加载正在进行



### **FCP的性能标准与测量**

**性能阈值**（Google建议）

| **评级** | **时间范围** |    **用户感知**    |
| :------: | :----------: | :----------------: |
|  ✅ 良好  |    ≤1.8秒    | 加载迅速，体验流畅 |
| ⚠️ 需改进 |   1.8~3秒    | 可感知延迟，需优化 |
|  ❌ 较差  |     >3秒     |  用户可能放弃等待  |

**测量方法**

PageSpeed Insights：综合真实用户数据与实验室模拟。

Lighthouse/Chrome DevTools：开发阶段本地测试。

Web-Vitals库：通过JS监听（代码示例👇）：

```js
import { onFCP } from 'web-vitals';
onFCP(metric => console.log('FCP:', metric.value));
```

**JS原生API（PerformanceObserver）**

```js
new PerformanceObserver((list) => {
  list.getEntriesByName('first-contentful-paint').forEach(entry => {
    console.log('FCP时间:', entry.startTime);
  });
}).observe({ type: 'paint', buffered: true });
```

### **优化FCP的关键策略**

**减少资源阻塞**FI

- CSS/JS优化：压缩、移除未使用代码（通过Chrome Coverage工具检测），异步加载非关键脚本（async/defer）。
- 字体优化：使用font-display: swap避免文字渲染延迟。

**提升服务器响应**

- 缓存静态资源：设置Cache-Control: max-age=31536000。
- CDN加速：分发内容至边缘节点，减少TTFB（首字节时间）。
- 服务器缓存：Nginx/Apache启用FastCGI缓存，减少动态处理。

**优化加载流程**

- 预加载关键请求：<link rel="preload" href="main.css">。
- 懒加载非首屏资源：图片添加loading="lazy"。
- 简化DOM结构：减少嵌套层级，加速渲染。

**避免常见陷阱**

- 重定向：多重重定向增加延迟，需合并或消除。
- 渲染阻塞JS：将脚本置于<body>底部或延迟执行











